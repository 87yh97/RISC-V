.text
subprog: 
  .globl subprog
    
    beqz a0, return         # Если массив пустой, то переходим сразу в конец
    
    remu a1, a1, a0         #a1 = a1 % a0, убираем полные круги сдвигов
    
    beqz a1, return         #Если сдвигов 0, то переходим в конец
    
    mv t5, a3               #Сохранение в t5 адреса array
        
    beqz a2, pass           # если a2 = 0, то переходим к сдвигу вправо
    sub a1, a0, a1          # a2 = a0 - a1, если задан сдвиг влево, то производится
                            # (len - n) сдвигов вправо
    
  pass:
    mv a2, a1               # помещаем в a2 номер первого замещаемого элемента в массиве
    mv t3, a0               # сохраняем количество замещений в t3
    
    mv a3, t5               # a3 = &array
    addi t4, zero, 4
    mul a4, a1, t4          # a4 = num_of_shifts * 4, помещаем относительный адрес первого замещаемого элемента
    mv a7, t5            
    add a4, a4, a7          # в a4 абсолютный адрес первого замещаемого элемента
    lw a5, 0(a3)            # помещаем в а5 первый элемент
    lw a6, 0(a4)            # помещаем в а6 первый замещаемый элемент
    
    
  shift_loop:
      beqz t3, return       # Если a0 = 0, то все замещения сделаны
      sw a5, 0(a4)          # Замещение элемента в массиве
      mv a5, a6             # Сохранение замещенного элемента
      mv a3, a4             # Сохранение адреса замещенного элемента
      add a2, a2, a1        # Добавляем к номеру замещаемого значение смещения
      remu a2, a2, a0       # a2 = a2 % a0 = a2 % array_len
      mul a4, a2, t4        # Получаем смещение замещаемого относительно начала массива в байтах
      #mv a7, t5             # Загружаем в a7 адрес начала массива
      add a4, a4, a7        # Получаем абсолютный адрес замещаемого элемента
      lw a6, 0(a4)          # Загружаем в a6 замещаемый элемент
      addi t3, t3, -1       # Уменьшаем количество оставшихся замещений на 1
      jal zero, shift_loop
      
      
  return:
      ret
      
      
      
      